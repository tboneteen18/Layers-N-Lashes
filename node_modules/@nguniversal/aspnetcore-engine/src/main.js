"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var platform_server_1 = require("@angular/platform-server");
var compiler_1 = require("@angular/compiler");
var tokens_1 = require("./tokens");
var file_loader_1 = require("./file-loader");
require("rxjs/add/operator/filter");
require("rxjs/add/operator/first");
function ngAspnetCoreEngine(options) {
    var compilerFactory = platform_server_1.platformDynamicServer().injector.get(core_1.CompilerFactory);
    var compiler = compilerFactory.createCompiler([
        {
            providers: [
                { provide: compiler_1.ResourceLoader, useClass: file_loader_1.FileLoader }
            ]
        }
    ]);
    return new Promise(function (resolve, reject) {
        try {
            var moduleOrFactory = options.ngModule;
            if (!moduleOrFactory) {
                throw new Error('You must pass in a NgModule or NgModuleFactory to be bootstrapped');
            }
            options.providers = options.providers || [];
            var extraProviders = options.providers.concat(options.providers, [
                {
                    provide: platform_server_1.INITIAL_CONFIG,
                    useValue: {
                        document: options.appSelector,
                        url: options.request.url
                    }
                },
                {
                    provide: tokens_1.ORIGIN_URL,
                    useValue: options.request.origin
                }, {
                    provide: tokens_1.REQUEST,
                    useValue: options.request.data.request
                }
            ]);
            var platform_1 = platform_server_1.platformServer(extraProviders);
            getFactory(moduleOrFactory, compiler)
                .then(function (factory) {
                return platform_1.bootstrapModuleFactory(factory).then(function (moduleRef) {
                    var state = moduleRef.injector.get(platform_server_1.PlatformState);
                    var appRef = moduleRef.injector.get(core_1.ApplicationRef);
                    appRef.isStable
                        .filter(function (isStable) { return isStable; })
                        .first()
                        .subscribe(function () {
                        // Fire the TransferState Cache
                        var bootstrap = moduleRef.instance.ngOnBootstrap;
                        bootstrap && bootstrap();
                        // The parse5 Document itself
                        var AST_DOCUMENT = state.getDocument();
                        // Strip out the Angular application
                        var htmlDoc = state.renderToString();
                        var APP_HTML = htmlDoc.substring(htmlDoc.indexOf('<body>') + 6, htmlDoc.indexOf('</body>'));
                        // Strip out Styles / Meta-tags / Title
                        // const STYLES = [];
                        var META = [];
                        var LINKS = [];
                        var TITLE = '';
                        var STYLES_STRING = htmlDoc.substring(htmlDoc.indexOf('<style ng-transition'), htmlDoc.lastIndexOf('</style>') + 8);
                        // STYLES_STRING = STYLES_STRING.replace(/\s/g, '').replace('<styleng-transition', '<style ng-transition');
                        var HEAD = AST_DOCUMENT.head;
                        var count = 0;
                        for (var i = 0; i < HEAD.children.length; i++) {
                            var element = HEAD.children[i];
                            if (element.name === 'title') {
                                TITLE = element.children[0].data;
                            }
                            // Broken after 4.0 (worked in rc) - needs investigation
                            // As other things could be in <style> so we ideally want to get them this way
                            // if (element.name === 'style') {
                            //   let styleTag = '<style ';
                            //   for (let key in element.attribs) {
                            //     if (key) {
                            //       styleTag += `${key}="${element.attribs[key]}">`;
                            //     }
                            //   }
                            //   styleTag += `${element.children[0].data}</style>`;
                            //   STYLES.push(styleTag);
                            // }
                            if (element.name === 'meta') {
                                count = count + 1;
                                var metaString = '<meta';
                                for (var key in element.attribs) {
                                    if (key) {
                                        metaString += " " + key + "=\"" + element.attribs[key] + "\"";
                                    }
                                }
                                META.push(metaString + " />\n");
                            }
                            if (element.name === 'link') {
                                var linkString = '<link';
                                for (var key in element.attribs) {
                                    if (key) {
                                        linkString += " " + key + "=\"" + element.attribs[key] + "\"";
                                    }
                                }
                                LINKS.push(linkString + " />\n");
                            }
                        }
                        // Return parsed App
                        resolve({
                            html: APP_HTML,
                            globals: {
                                styles: STYLES_STRING,
                                title: TITLE,
                                meta: META.join(' '),
                                links: LINKS.join(' ')
                            }
                        });
                        moduleRef.destroy();
                    }, function (err) {
                        reject(err);
                    });
                });
            });
        }
        catch (ex) {
            reject(ex);
        }
    });
}
exports.ngAspnetCoreEngine = ngAspnetCoreEngine;
/* ********************** Private / Internal ****************** */
var factoryCacheMap = new Map();
function getFactory(moduleOrFactory, compiler) {
    return new Promise(function (resolve, reject) {
        // If module has been compiled AoT
        if (moduleOrFactory instanceof core_1.NgModuleFactory) {
            resolve(moduleOrFactory);
            return;
        }
        else {
            var moduleFactory = factoryCacheMap.get(moduleOrFactory);
            // If module factory is cached
            if (moduleFactory) {
                resolve(moduleFactory);
                return;
            }
            // Compile the module and cache it
            compiler.compileModuleAsync(moduleOrFactory)
                .then(function (factory) {
                factoryCacheMap.set(moduleOrFactory, factory);
                resolve(factory);
            }, (function (err) {
                reject(err);
            }));
        }
    });
}
//# sourceMappingURL=main.js.map